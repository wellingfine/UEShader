
// from 4-Deform.ush

float3 rayOrigin=1+worldPos-viewDir;
float3 rayStep=viewDir*-1;

float3 lightDir=normalize(lightPos);

// 不理解
struct sdfShapes {
    float donut(float3 p,float size,float cutout) {
        float2 q=float2(length(p.xz)-size,p.y);
        return length(q)-cutout;
    }
};
sdfShapes sdf;

for(int i=0;i<count;i++) {
    float dist=sdf.donut(rayOrigin,50,25);

    opacityMask=1;
    if(dist<0.01) {
        // 计算SDF法线（中心差分法）  <---AI生成
        float eps = 0.001;
        float3 normal = normalize(float3(
                sdf.donut(rayOrigin + float3(eps, 0, 0), 50, 25) - 
                sdf.donut(rayOrigin - float3(eps, 0, 0), 50, 25),
                sdf.donut(rayOrigin + float3(0, eps, 0), 50, 25) - 
                sdf.donut(rayOrigin - float3(0, eps, 0), 50, 25),
                sdf.donut(rayOrigin + float3(0, 0, eps), 50, 25) - 
                sdf.donut(rayOrigin - float3(0, 0, eps), 50, 25)));

        float diffuse=max(dot(normal,lightDir),0);

        float3 reflection=reflect(lightDir,normal);
        float3 viewDirection=normalize(-worldPos-rayOrigin);
        float specular=pow(max(dot(reflection,viewDirection),0),16);

        return (diffuse*float3(1,0,0)) + (specular*float3(1,1,1));
    }

    rayOrigin+=rayStep;
}
opacityMask=0;

return float3(0,0,0);